// src/services/websocketService.js (ì „ì²´ ìˆ˜ì •)
import { Client } from '@stomp/stompjs';
import SockJS from 'sockjs-client';

class WebSocketService {
  constructor() {
    this.client = null;
    this.connected = false;
    this.subscriptions = new Map();
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = 5;
  }

  connect(token) {
    // ðŸ’¡ 1. ì¸ìžë¥¼ í† í°ë§Œ ë°›ë„ë¡ ë‹¨ìˆœí™”í–ˆìŠµë‹ˆë‹¤.
    return new Promise((resolve, reject) => {
      if (!token) {
        reject(new Error('ì¸ì¦ í† í°ì´ ì—†ìŠµë‹ˆë‹¤.'));
        return;
      }

      if (this.client && this.client.connected) {
        console.log('ì´ë¯¸ WebSocketì— ì—°ê²°ë˜ì–´ ìžˆìŠµë‹ˆë‹¤.');
        resolve(this.client);
        return;
      }

      const wsUrl = `${process.env.REACT_APP_API_BASE_URL}/ws-consultation`;
      console.log('WebSocket ì—°ê²° URL:', wsUrl);

      const socket = new SockJS(wsUrl);

      this.client = new Client({
        webSocketFactory: () => socket,
        connectHeaders: {
          Authorization: `Bearer ${token}`,
        },
        debug: (str) => {
          console.log('[WebSocket Debug]', str);
        },
        reconnectDelay: 5000,
        heartbeatIncoming: 4000,
        heartbeatOutgoing: 4000,
      });

      this.client.onConnect = () => {
        console.log('WebSocketì´ ì„±ê³µì ìœ¼ë¡œ ì—°ê²°ë˜ì—ˆìŠµë‹ˆë‹¤.');
        this.connected = true;
        this.reconnectAttempts = 0;
        resolve(this.client);
      };

      this.client.onStompError = (frame) => {
        console.error('WebSocket ì˜¤ë¥˜:', frame.headers['message']);
        reject(new Error(frame.headers['message']));
      };

      this.client.onWebSocketClose = () => {
        console.log('WebSocket ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤.');
        this.connected = false;
        // ìž¬ì—°ê²° ë¡œì§ì€ ìœ ì§€í•©ë‹ˆë‹¤.
        // this.handleReconnect(token);
      };

      this.client.activate();
    });
  }

  // ðŸ’¡ 2. AuthProviderì—ì„œ í˜¸ì¶œí•  ìˆ˜ ìžˆë„ë¡, ê¸°ì¡´ subscribeToPersonalChannel í•¨ìˆ˜ë¥¼ ëŒ€ì²´í•˜ëŠ” ìƒˆ í•¨ìˆ˜ë¥¼ ë§Œë“¤ì—ˆìŠµë‹ˆë‹¤.
  subscribeToNotifications(onNotificationReceived) {
    if (!this.connected || !this.client) {
      console.error('WebSocketì´ ì—°ê²°ë˜ì§€ ì•Šì•„ ì•Œë¦¼ì„ êµ¬ë…í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
      return;
    }

    // ðŸ’¡ 3. ì„œë²„ê°€ ë©”ì‹œì§€ë¥¼ ë³´ë‚´ëŠ” ì •í™•í•œ ê°œì¸ ì±„ë„ ì£¼ì†Œìž…ë‹ˆë‹¤.
    const destination = '/user/queue/consultations';

    if (this.subscriptions.has('notifications')) {
      console.warn('ì´ë¯¸ ì•Œë¦¼ ì±„ë„ì„ êµ¬ë… ì¤‘ìž…ë‹ˆë‹¤.');
      return;
    }

    console.log(`ì•Œë¦¼ ì±„ë„ êµ¬ë…ì„ ì‹œìž‘í•©ë‹ˆë‹¤: ${destination}`);
    const subscription = this.client.subscribe(destination, (message) => {
      try {
        const notification = JSON.parse(message.body);
        // AuthProviderì—ì„œ ì „ë‹¬ë°›ì€ ì½œë°± í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•˜ì—¬ ì•Œë¦¼ ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
        onNotificationReceived(notification);
      } catch (e) {
        console.error('ì•Œë¦¼ ë©”ì‹œì§€ íŒŒì‹± ì˜¤ë¥˜:', e);
      }
    });

    this.subscriptions.set('notifications', subscription);
  }

  // ... ì´í•˜ ê¸°ì¡´ì— ì‚¬ìš©í•˜ì‹œë˜ ë‹¤ë¥¸ ë©”ì„œë“œë“¤ì€ ê·¸ëŒ€ë¡œ ìœ ì§€í•˜ì‹œë©´ ë©ë‹ˆë‹¤ ...
  // (subscribeToRoom, unsubscribeFromRoom, sendMessage, isConnected ë“±)

  // roomUuid ë§¤ê°œë³€ìˆ˜ë¡œ ë³€ê²½ (ë°±ì—”ë“œê°€ roomUuidë¥¼ ê¸°ëŒ€í•¨)
  subscribeToRoom(roomUuid, callbacks) {
    if (!this.connected) return;
    const destination = `/topic/consultation/${roomUuid}`;
    console.log('[WebSocket] Subscribing to room:', destination);
    if (!this.subscriptions.has(destination)) {
      const sub = this.client.subscribe(destination, (message) => {
        console.log('[WebSocket] Received message:', message.body);
        if (callbacks.onMessage) callbacks.onMessage(JSON.parse(message.body));
      });
      this.subscriptions.set(destination, sub);
    }
  }

  // roomUuid ë§¤ê°œë³€ìˆ˜ë¡œ ë³€ê²½
  unsubscribeFromRoom(roomUuid) {
    const destination = `/topic/consultation/${roomUuid}`;
    const sub = this.subscriptions.get(destination);
    if (sub) {
      sub.unsubscribe();
      this.subscriptions.delete(destination);
    }
  }

  // roomUuid ë§¤ê°œë³€ìˆ˜ë¡œ ë³€ê²½ (ë°±ì—”ë“œê°€ roomUuidë¥¼ ê¸°ëŒ€í•¨)
  sendMessage(roomUuid, content, messageType = 'TEXT') {
    if (!this.connected || !this.client) {
      console.error('WebSocket not connected');
      return;
    }
    const message = { content, messageType, timestamp: new Date().toISOString() };
    console.log('[WebSocket] Sending message to:', `/app/consultation/${roomUuid}/send`, message);
    this.client.publish({
      destination: `/app/consultation/${roomUuid}/send`,
      body: JSON.stringify(message),
    });
  }

  disconnect() {
    if (this.client) {
      this.client.deactivate();
      this.client = null;
      this.connected = false;
      this.subscriptions.clear();
    }
  }

  isConnected() {
    return this.connected;
  }
}

const websocketService = new WebSocketService();
export default websocketService;
